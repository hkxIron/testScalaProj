    public class TestUTF8 {
        public static void main(String[] args) throws Exception {
            byte[][] bytes = {
// 00110001
                    {(byte)0x31},

// 11000000 10110001
                    {(byte)0xC0,(byte)0xB1},

// 11100000 10000000 10110001
                    {(byte)0xE0,(byte)0x80,(byte)0xB1},

// 11110000 10000000 10000000 10110001
                    {(byte)0xF0,(byte)0x80,(byte)0x80,(byte)0xB1},
// 11111000 10000000 10000000 10000000 10110001
                    {(byte)0xF8,(byte)0x80,(byte)0x80,(byte)0x80,(byte)0xB1},
// 11111100 10000000 10000000 10000000 10000000 10110001
                    {(byte)0xFC,(byte)0x80,(byte)0x80,(byte)0x80,(byte)0x80,(byte)0xB1},

                    {(byte)0xE4,(byte)0xB8,(byte)0xA5 }, // 严
                    /* 汉字"严"unicode是十六进制数4E25:100111000100101, 也就是说这个符号的表示至少需要2个字节
                    Unicode符号范围 | UTF-8编码方式
                    (十六进制) | （二进制）
                    --------------------+---------------------------------------------
                    0000 0000-0000 007F | 0xxxxxxx
                    0000 0080-0000 07FF | 110xxxxx 10xxxxxx
                    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
                    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

                    已知“严”的unicode是4E25（100111000100101），
                    根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），
                    因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。
                    然后，从“严”的最后一个二进制位开始, 100 111000 100101 => 0100 111000 100101 => [1110]0100 [10]111000 [10]100101
                    依次从后向前填入格式中的x，多出的位补0。
                    这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是: E4B8A5。

                    */

            };
            for (int i = 0; i < bytes.length; i++) {
                String str = new String(bytes[i], "UTF-8");
                System.out.println("原数组长度：" + bytes[i].length +
                        "\t转换为字符串：" + str +
                        "\t转回后字符串数组长度：" + str.getBytes("UTF-8").length);
            }
        }
    }
/**
 *UTF-8是一种变长字节编码方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。
 * 如表：
 * 1字节 0xxxxxxx
 * 2字节 110xxxxx 10xxxxxx
 * 3字节 1110xxxx 10xxxxxx 10xxxxxx
 * 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
 * 因此UTF-8中可以用来表示字符编码的实际位数最多有31位，即上表中x所表示的位。除去那些控制位（每字节开头的10等），这些x表示的位与UNICODE编码是一一对应的，位高低顺序也相同。
 * 实际将UNICODE转换为UTF-8编码时应先去除高位0，然后根据所剩编码的位数决定所需最小的UTF-8编码位数。
 * 因此那些基本ASCII字符集中的字符（UNICODE兼容ASCII）只需要一个字节的UTF-8编码（7个二进制位）便可以表示。
 *
 *
  1. 00110001 -> 对比utf8编码,使用1字节, 提取UNICODEf二进制编码: 011 0001 -> int=49 -> ascii码: 1
 *
 * 2.对于上面的问题，代码中给出的两个字节是
 * {(byte)0xC0,(byte)0xB1},
 * 十六进制：C0 B1
 * 二进制：11000000 10110001
 * 对比两个字节编码的表示方式：
 * 110xxxxx 10xxxxxx
 * 提取出对应的UNICODE编码：
 * 00000 110001
 *
 * 而110001对应的编码为49:即 串 "1" 的ascii码,所以转换完str后的串为"1"
 *
 * 可以看出此编码并非“标准”的UTF-8编码，因为其第一个字节的“有效编码”全为0，去除高位0后的编码仅有6位。
 * 由前面所述，此字符仅用一个字节的UTF-8编码表示就够了。
 * JAVA在把字符还原为UTF-8编码时，是按照“标准”的方式处理的，因此我们得到的是仅有1个字节的编码。
 *
 *
 * 3.
  11100000 10000000 10110001
 {(byte)0xE0,(byte)0x80,(byte)0xB1},

 对比3字节编码 1110xxxx 10xxxxxx 10xxxxxx
 提取UNICODEf二进制编码: [1110]0000 [10]000000 [10]110001
        => 0000 000000 110001
        => 00000000 00110001
        => 00110001 => int=49 => ascii:"1"

  */

/*
测试输出为:

原数组长度：1	转换为字符串：1	转回后字符串数组长度：1
原数组长度：2	转换为字符串：��	转回后字符串数组长度：6 (并非一个有效的utf8编码,因此输出为乱码)
原数组长度：3	转换为字符串：���	转回后字符串数组长度：9
原数组长度：4	转换为字符串：����	转回后字符串数组长度：12
原数组长度：5	转换为字符串：�����	转回后字符串数组长度：15
原数组长度：6	转换为字符串：������	转回后字符串数组长度：18
原数组长度：3	转换为字符串：严	转回后字符串数组长度：3
 */